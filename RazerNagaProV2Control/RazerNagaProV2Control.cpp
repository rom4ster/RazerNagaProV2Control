// RazerNagaProV2Control.cpp : This file contains the 'main' function. Program execution begins and ends there.
//

#include <iostream>
#include "../hidapi/hidapi.h"
#include "RazerNagaProV2Control.h"
#include "Util.h"
#include "CommandData.h"
#include <map>
#include <algorithm>
#include <vector>
#include <fstream>
#include <string>
#include <iomanip>
#include <sstream>


#define RAZER_COMMAND_LENGTH 90

#define RAZER_VID 5426
#define NAGAV2PRO_PID 167
#define MOUSE_USAGE_PAGE  1
#define MOUSE_USAGE 2

#define razer_write_button(X)  razer_button_action(true, X)
#define razer_write_button_if_not_null(X)  if (X != nullptr) {razer_button_action(true, X); }
#define razer_read_button(X) razer_button_action(false, X)

#define KEYBOARD_CATEGORY_DATA_LEN 0x2;
#define MOUSE_CATEGORY_DATA_LEN 0x1;


#define INTERACTION(X,Z) create_interaction_struct( (char *) X, (char *) Z)

#define INTERACTION_GET(Y)  interaction_get(args, (char *) Y)
#define SET_INTERACTION_PTR(A) argmap_ptr = A
#define CLEAR_INTERACTION_PTR() argmap_ptr = nullptr

#define tohex(X) strtol(X, NULL, 16)

hid_device* dev = NULL;

std::vector<interaction*> interactions;

std::map<std::string, char> * argmap_ptr = nullptr;
std::vector<std::vector<char>> config;



char interaction_get(std::map<std::string, char> * m, char * argument) {

    if (argmap_ptr == nullptr) {
        std::cerr << "Invalid argument map pointer" << std::endl;
        exit(-1);
    }

    int value = 0x0;
   

    if (mapexists<std::string, char>(m, std::string(argument))) { value = m->at(std::string(argument)); }
    else {
        char* prompt = std::find_if(
            std::begin(interactions), 
            std::end(interactions), 
            [&](const interaction* v) { return std::string(v->name) == std::string(argument); })[0]->question; 
            std::cout << prompt << std::endl; 
            std::string input;

            // Read a full line of input
            std::getline(std::cin, input);
            value = std::stoi(input, nullptr, 16);
}

    return value;
}



bool findInfo(hid_device_info** outt, hid_device_info* list, int* path) {
    hid_device_info* out = nullptr;
    if (path == nullptr) {
        hid_device_info temp;
        temp.next = list;
        out = &temp;
        while ((out = out->next) != nullptr) std::cout << out->usage_page << " " << out->usage << " " << out->interface_number << "\n";
        return false;
    }
    out = nullptr;
    if (list == nullptr) return false;
    out = list;
    while (out != nullptr && out->usage_page != path[0] && out->usage != path[1]) out = out->next;
    *outt = out;
    return out != nullptr;

}


interaction * create_interaction_struct(char* name, char* question) {

    interaction * intr = new interaction;

    intr->name = name;
    intr->question = question;

    return intr;
}






razer_command * razer_get_report() {
    
    unsigned char data [RAZER_COMMAND_LENGTH + 1];

    zeroarr(data, RAZER_COMMAND_LENGTH + 1);

    auto res = hid_get_feature_report(dev, data, RAZER_COMMAND_LENGTH + 1);

    

    if (res < 0) {
        delete[] data;
        return nullptr;
    }
    auto ret = new unsigned char[RAZER_COMMAND_LENGTH];
    
    memcpy(ret, data+1, RAZER_COMMAND_LENGTH);

    return (razer_command*) ret;
}


/**
 *  ADAPTED FROM FROM  https://github.com/openrazer/openrazer/blob/master/driver/razercommon.c
 * Calculate the checksum for the usb message
 *
 * Checksum byte is stored in the 2nd last byte in the messages payload.
 * The checksum is generated by XORing all the bytes in the report starting
 * at byte number 2 (0 based) and ending at byte 88.
 */
void razer_calculate_crc(razer_command * report)
{
    /*second to last byte of report is a simple checksum*/
    /*just xor all bytes up with overflow and you are done*/
    unsigned char crc = 0;
    unsigned char* _report = (unsigned char*)report;

    unsigned int i;
    for (i = 2; i < RAZER_COMMAND_LENGTH-2; i++) {
        crc ^= _report[i];
    }

    report->crc = crc;
}




bool razer_set_report(razer_command* command) {
    
    unsigned char data[RAZER_COMMAND_LENGTH + 1];
    zeroarr(data, RAZER_COMMAND_LENGTH + 1);


    auto prev = razer_get_report();
    command->tid = prev->tid + 1;

    razer_calculate_crc(command);

    auto size = sizeof(command);

    unsigned char* start = data + 1;
    memcpy(start, (unsigned char *) command, RAZER_COMMAND_LENGTH);

    
    auto res = hid_send_feature_report(dev, data, RAZER_COMMAND_LENGTH + 1);
    
    return res >= 0;

}


void razer_button_action(bool write, button_command * button_command) {
    
    razer_command * command = new razer_command(); 
    class_id command_class;
    command_class.command_class = 0x02;
    command_class.id = write ? 0x0C : 0x8C;


    command->status = NEW;
    command->packets_remaining = 0x0;
    command->prototype = CONSTANT;
    command->data_size = write ?  RAZER_BUTTON_COMMAND_SIZE : RAZER_BUTTON_COMMAND_READ_SIZE;
    command->command = command_class;
    
    unsigned char * dataptr =  (unsigned char *) command->data;
    zeroarr(dataptr, command->data_size);

    memcpy(dataptr, button_command, sizeof(button_command));

    auto ret = razer_set_report(command);

    std::cout << "Success? -> " << ret << std::endl;


}

button_command* keyboard_command(char profile, BUTTON_VALUES button_num, HYPERSHIFT hypershift, char hid_modifier, char hid_button) {

    button_command* ret = new button_command;
    

    ret->profile = profile;
    ret->num = button_num;
    ret->hypershift = hypershift;
    ret->category = KEYBOARD_KEY;
    ret->data_len = KEYBOARD_CATEGORY_DATA_LEN;
    
    zeroarr(ret->data, 5);

    ret->data[0] = hid_modifier;
    ret->data[1] = hid_button;
    
    return ret;

    
}

button_command* mouse_command(char profile, BUTTON_VALUES button_num, HYPERSHIFT hypershift, BINDABLE_MOUSE_BUTTONS mouse_button_bind) {
    button_command* ret = new button_command;

    ret->profile = profile;
    ret->num = button_num;
    ret->hypershift = hypershift;
    ret->category = MOUSE_BUTTON;
    ret->data_len = MOUSE_CATEGORY_DATA_LEN;
    zeroarr(ret->data, 5);

    ret->data[0] = mouse_button_bind;

    return ret;
    
}

button_read * read_command(char profile, BUTTON_VALUES button_num, HYPERSHIFT hypershift) {
    
    button_read * ret = new button_read;

    ret->profile = profile;
    ret->num = button_num;
    ret->hypershift = hypershift;



    return ret;

    
}


inline bool fexists(const std::string& name) {
    struct stat buffer;
    return (stat(name.c_str(), &buffer) == 0);
}



void init_config() {

    if (!fexists("config")) {
        std::ofstream file;
        file.open("config");
        if (!file.is_open()) {
            std::cerr << "Could not create config" << std::endl;
            exit(-1);
        }
        file.close();
    }
    std::ifstream file("config");
    if (!file) {
        std::cerr << "Error: Unable to open file 'config'" << std::endl;
        exit(-1);
    }

    std::string line;
    while (std::getline(file, line)) {
        std::istringstream iss(line);
        std::string token;
        std::vector<char> row;

        while (iss >> token) {
            std::istringstream converter(token);
            int value;
            if (converter >> std::hex >> value && value >= 0 && value <= 255) {
                row.push_back(static_cast<char>(value));
            }
            else {
                row.clear();
                break;
            }
        }

        if (row.size() == 6) {
            config.push_back(row);
        }
    }

    file.close();
}

void write_config() {
    std::ofstream outFile("config");
    if (!outFile.is_open()) {
        std::cerr << "Failed to open file: " << "config" << std::endl;
        return;
    }

    for (const auto& innerVec : config) {
        for (const char& ch : innerVec) {
            // Write each character as its 2-digit hex code
            outFile << std::hex << std::setw(2) << std::setfill('0') << (static_cast<int>(ch) & 0xFF) << " ";
        }
        outFile << std::endl; // New line for each inner vector
    }

    outFile.close();

}

void clear_config() {
    std::ofstream file("config", std::ios::trunc);

    if (!file.is_open()) {
        std::cerr << "Failed to open the file!" << std::endl;
        return;
    }

    // Closing the file will save the changes (empty content)
    file.close();
}





void init_interactions() {

    interactions.push_back(INTERACTION("restore", "Restore or Write Operation? 0 for restore 1 for write"));
    interactions.push_back(INTERACTION("profile", "Which Profile (0 for non persist profile)"));
    interactions.push_back(INTERACTION("button", "What is the number of the button you want to change"));
    interactions.push_back(INTERACTION("hypershift", "Is this the hypershift profile (yes 1, no 0)?"));
    interactions.push_back(INTERACTION("category", "What Category of Keybind do you wish to do (keyboard is 2 and mouse is 1)?"));
    interactions.push_back(INTERACTION("bind_modifier", "What modifier would you apply to your bind? (0 for null)"));
    interactions.push_back(INTERACTION("bind_key", "What do you wish to bind this too?"));


}




void init() {
    if (dev != NULL) {
        return;
    }
    init_interactions();
    init_config();
    hid_device_info* info = NULL;
    auto info_list = hid_enumerate(RAZER_VID, NAGAV2PRO_PID);
    int nums[]{ MOUSE_USAGE_PAGE, MOUSE_USAGE };
    bool found = findInfo(&info, info_list, nums);
    if (!found) {
        std::cerr << "Device Info For Page " << nums[0] << " and Usage" << nums[1] << " NOT FOUND" << std::endl;
        exit(-1);
    }
    auto hidptr = hid_open_path(info->path);
    if (hidptr == NULL) { std::cerr << "Bad Pointer Could not Open Device \n"; exit(-1); }
    dev = hidptr;
}

void quit() {
    if (dev != NULL) { 
        hid_close(dev);
    }
}





std::map<std::string, char> * parse_args(int argc, char ** argv) {
    if (argc < 1) {
        std::cerr << "Invalid Arg Count: " << argc << std::endl;
    }

    auto argmap = new std::map<std::string, char>;

    for (int i = 1; i < argc;) {
        if (i + 1 >= argc) {
            std::cerr << "No value found for key: " << argv[i] << std::endl;
            exit(-1 * i);
        }

        std::string key = std::string(argv[i]);
        char value = tohex(argv[i+1]);
        argmap->insert(std::make_pair(key, value));
        
    }

    return argmap;

}





void interact(std::map<std::string, char> * args) {

    button_command* cmd = nullptr;
    
    SET_INTERACTION_PTR(args);
    char restore = INTERACTION_GET("restore");

    

    
    
    
    
    if (restore == 0) {

      // button_read * cmdr = read_command(profile, (BUTTON_VALUES) button, hypershift == 0 ? OFF: ON);
      // //cowboy cast this to button_command * as it will become cowboy cast to unsigned char * anyways. 
      // razer_read_button( (button_command *) cmdr);

        for (int i = 0; i < config.size(); i++) {
            
            auto cmd_list = config[i];

            char profile = cmd_list[0];
            char button = cmd_list[1];
            char hypershift = cmd_list[2];
            char category = cmd_list[3];
            char modifier = cmd_list[4];
            char bind = cmd_list[5];

            if (category == 0x2) {
                //char modifier = INTERACTION_GET("bind_modifier");
                cmd = keyboard_command(profile, (BUTTON_VALUES)button, hypershift == 0 ? OFF : ON, modifier, bind);
            }

            if (category == 0x1) {
                cmd  = mouse_command(profile, (BUTTON_VALUES)button, hypershift == 0 ? OFF : ON, (BINDABLE_MOUSE_BUTTONS)bind);
            }
            
            razer_write_button_if_not_null(cmd);
        }

     
    }
    else {
        char profile = INTERACTION_GET("profile");
        char button = INTERACTION_GET("button");
        char hypershift = INTERACTION_GET("hypershift");

        char category = INTERACTION_GET("category");
        char bind = INTERACTION_GET("bind_key");
        char modifier = 0x0;
        if (category == 0x02) {
            modifier = INTERACTION_GET("bind_modifier");
        }

        if (category == 0x2) {
             
            cmd = keyboard_command(profile, (BUTTON_VALUES)button, hypershift == 0 ? OFF : ON, modifier, bind);
        }

        if (category == 0x1) {
            cmd = mouse_command(profile, (BUTTON_VALUES)button, hypershift == 0 ? OFF : ON, (BINDABLE_MOUSE_BUTTONS)bind);
        }

        std::vector<char> charList;
        charList.push_back(profile);
        charList.push_back(button);
        charList.push_back(hypershift);
        charList.push_back(category);
        charList.push_back(modifier);
        charList.push_back(bind);

        for (int i = 0; i < config.size(); i++) {
            bool eq = true;
            for (int j = 0; j < 3; j++) {
                if (charList[j] != config[i][j]) {
                    eq = false;
                }
            }
            if (eq) {
                config.erase(config.begin() + i);
                break;
            }
        }
        config.push_back(charList); 
        clear_config();
        write_config();
        

        razer_write_button_if_not_null(cmd);
    }


    

    CLEAR_INTERACTION_PTR();
}





int main(int argc, char ** argv )
{
    std::cout << "Hello World!\n";
    init();
    
    interact(parse_args(argc, argv));
    auto tst  = razer_get_report();
    std::cout << (int)tst->status << " " << (int)tst->tid << " " << (int)tst->command.command_class << (int)tst->command.id << std::endl;
    
    quit();
    exit(-1);
    auto ret = razer_get_report();
    std::cout << (int) ret->status << " " << (int) ret->tid << " " <<  (int) ret->command.command_class <<(int) ret->command.id << std::endl;
    auto btn_info = keyboard_command(0x01,(BUTTON_VALUES) 0x40, OFF, 0x0, 0x0A);

    razer_write_button(btn_info);

    ret = razer_get_report();
    std::cout << (int)ret->status << " " << (int)ret->tid << " " << (int)ret->command.command_class << (int)ret->command.id << std::endl;

    quit();


}

// Run program: Ctrl + F5 or Debug > Start Without Debugging menu
// Debug program: F5 or Debug > Start Debugging menu

// Tips for Getting Started: 
//   1. Use the Solution Explorer window to add/manage files
//   2. Use the Team Explorer window to connect to source control
//   3. Use the Output window to see build output and other messages
//   4. Use the Error List window to view errors
//   5. Go to Project > Add New Item to create new code files, or Project > Add Existing Item to add existing code files to the project
//   6. In the future, to open this project again, go to File > Open > Project and select the .sln file
